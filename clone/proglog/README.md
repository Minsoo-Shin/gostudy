# HTTP JSON 서비스 적용
JSON API는 웹에서 가장 일반적으로 사용하는 API이다. 대부분의 언어가 JSON을 기본적으로 지원하므로 만들기 쉽기 때문이다.
또한 JSON은 사람이 읽기 쉽고, HTTP API는 터미널에서 curl로 호출하거나 브라우저로 열기만 하면 된다.

JSON/HTTP는 작은 웹서비스에만 적합한 것이 아니다. 유명한 오픈소스인 elasticsearch나 etcd 같은 프로젝트도 고객이 사용하는 API로 JSON/HTTP를 사용하며, 내부 노드 간 통신에는
성능 향상을 위해 그달만의 바이너리 프로토콜을 사용한다.

고는 표준 라이브러리만으로 JSON/HTTP를 구현을 쉽게 할 수 있다. 고의 선언 태그와 표준 라이브러리의 encoding/json 패키지를 사용하면 직렬화가 간편하다.

## 커밋 로그 만들기
처음 프로토타입으로 커밋 로그를 만들 땐, 커밋 로그가 추가만 할 수 있는 데이터 구조체이다. 연속한 레코드로 이루어지고 시간순으로 정렬된다.
이처럼 간단한 커밋 로그는 슬라이스로 만든다.

## 프로토콜 버퍼와 구조체
서비스들은 네트워크로 통신한다. 구조체와 같은 데이터를 네트워크로 보내려면 데이터를 전송할 수 있는 형태로 인코딩해야한다. 대표적 형태가 JSON이다.
pulic API나 클라이언트를 통제할 수 없는 프로젝트를 만든다면 JSON을 선택한다.

하지만 private API 또는 클라이언트를 통제할 수 있는 상황이라면 JSON보다 더 나은 데이터 구조화와 전송방식을 선택할 수 있다.
그게 바로 프로토콜 버퍼 (protobuf)는 언어와 플랫폼에 상관없이 쓸 수 있고 확장할 수 있는, 데이터를 구조화하고 직렬화하는 메커니즘이다.
### 장점
- 자료형 안정성 보장
- 스키마 위반 방지
- 빠른 직렬화
- 하위 호환성 제공

1. 일관된 스키마
> protobuf로 의미하는 semantics를 인코딩하고 서비스 전반에 걸쳐 사용하면 전체 시스템 일관성을 보장할 수 있다.
> 고 언어의 자료형 검사를 통해 구조체 의존성을 업데이트하고 변경한 데이터 모델을 테스트할 수 있다.
> 이렇게 컴파일과 테스트를 마치면 스키마의 일관성에 문제가 없는지 확인할 수 있다.
2. 버전 관리 제거
> 구글이 protobuf를 만든 이유 중 하나는 버전을 확인할 필요성을 없애고 지저분한 코드를 피하려고 했다.
> protobuf는 필드마다 번호를 매기는데, 새로운 기능을 내놓거나 변경할 때 하위 호환성을 관리하려는 것이다.
> 덕분에 새로운 필드를 추가하기 쉽고, 파싱하고 전달만 하는 중간 서버는 모든 필드를 알 필요가 없다.
> 필드를 제거할 때는 더 이상 사용하지 않는 필드에 'reserved'라고 표시만 하면, 컴파일할 때, 해당 필드를 사용하려는 코드가 있는지 체크해준다.


3. 줄어드는 보일러플레이트 코드
> 컴파일로 생성한 protobuf 라이브러리에 인코딩과 디코딩 메서드가 만들어진다. 직접 코드를 짤 필요가 없다.

4. 확장성
> protobuf 컴파일러는 자신만의 컴파일 로직으로 컴파일할 수 있다. 예를 들어, 여러 구조체가 공통의 메서드를 가지게 하려면, protobuf에서 자동으로 해당 메서드를 생성하는 플러그인을 만들 수 있다.

5. 언어 불가지론
> 여러 언어가 가능하다. protobuf 버전 3.0 이후(C++, Go, Java, Python, Ruby, C#, Object-C, PHP)를 지원한다.

6. 성능
> 고성능이며 페이로드가 적고, 직렬화할 때 JSON보다 6배 빠르다. gRPC는 API 정의 및 메시지 직렬화에 프로토콜 버퍼를 사용한다.

## 로그 패키지 작성
로그 패키지는 분산 서비스에서 가장 중요한 도구라고 생각한다. 미리 쓰기 로그 (WAL), 트랜잭션 로그, 커밋 로그 등으로 부르는 로그는 스토리지 엔진
, 메시지 큐, 버전 컨트롤, replication, 합의 알고리즘의 핵심이다. 분산 시스템을 만들며 마주치는 많은 문제는 로그로 해결할 수 있다.

- 로그를 이용해 문제를 해결하거나, 여러운 문제를 좀 더 쉽게 만드는 방법
- 기존의 로그 기반 시스템을 변경하거나 새로운 로그 기반 시스템을 만드는 방법
- 데이터를 효율적으로 읽고 쓰는 스토리지 엔진을 만드는 방법
- 시스템 오류에도 데이터 손실을 막는 방법
- 데이터를 디스크에 저장하기 위해 인코딩하거나 자신만의 와이어 프로토콜을 만들고 애플리케이션 간 전송하는 방법

### 로그는 강력한 도구
ext 파일 시스템의 경우 로그는 직접적으로 디스크의 데이터 파일을 바꾸기보다는 저널을 변경한다. 파일 시스템이 저널에 로그를 안전하게 쓰고 나면, 이 변경사항을 데이터 파일에 적용한다.
저널에 로그를 쓰는 건 단순하면서도 빠르므로 데이터를 잃을 가능성이 적다. ext가 디스크의 파일을 업데이트하지 못하고 컴퓨터가 꺼지더라도,
다음번 부팅에서 파일 시스템이 다시 저널을 보고 파일 업데이트를 완료한다. (postgresql 역시 동일)

WAL 복제에도 사용한다. 로그를 디스크에 쓰는 대신 네트워크 너머의 복제본 replica에 쓰는 것이다. 이 복제본은 이를 다시 데이터 카피에 반영하고 둘은 같은 상태가 된다.
래프트Raft와 같은 분산 합의 알고리즘은 이러한 아이디어를 분산 서비스가 클러스터 전반의 상태에 대해 합의할 때 사용한다.

### 로그 작동 원리
로그는 추가만 할 수 있는 레코드의 연속이다. 로그를 실제로 구현하며 마주치는 첫번째 문제는 무한한 용량의 디스크는 없다는 점이다.
파일 하나에 끝없이 추가할 수는 없으므로 여러 개의 세그먼트로 나눈다. 로그가 지나치게 커지면,
이미 필요한 처리를 마쳤거나 다른 공간에 별도로 보관한 오래된 세그먼트부터 지우면서 디스크 용량을 확보한다. (백그라운드로 처리)

세그먼트 목록에는 항상 하나의 활성 세그먼트가 있다. 유일하게 레코드를 쓸 수 있는 세그먼트로, 활성 세그먼트가 가득 차면 새로운 세그먼트르 생성하여 활성 세그먼트로 만든다.
세그먼트는 저장 파일과 인덱스 파일로 구성된다. 저장 파일에는 데이터를 저장하고, 인덱스 파일에는 그 레코드들의 인덱스를 저장한다. 인덱스 파일은 레코드의 오프셋을 저장 파일의 실제 위치로 매핑해서 빠르게 읽을 수 있도록 한다.
인덱스 파일 (오프셋/레코드 저장 파일 위치) 두 필드만 가지고 있어 저장소 파일보다 훨씬 작아 메모리 맵 파일로 만들어 빠르게 만들 수 있다.


# 네트워크를 통한 서비스 구축
네트워크를 통해서 여러 사람이 사용할 수 있는 서비스를 구축해볼 것이다. 네트워크로 서비스하면 세가지 이점을 제공한다.
- 가용성과 확장성을 위해 여러 컴퓨터에 걸쳐 실행할 수 있다.
- 여러 사람이 같은 데이터로 소통할 수 있다.
- 사람들이 쉽게 접근하고 사용할 수 있는 인터페이스를 제공한다.

현재 분산 서비스에 대한 요청을 처리하는 최고의 도구는 구글의 gRPC이다.

# gRPC란,
## gRPC에 관하여
분산 서비스를 만들 때, 가장 어려운 문제는 호환성을 유지하는 문제와 서버-클라이언트 사이의 성능을 관리하는 문제이다.

첫 번째로는, 서버의 호환성을 깨는 변경사항을 만들더라도 기존 고객들에게는 아무 문제 없도록 API 버저닝으로 해결한다.
두 번째로, 좋은 성능을 유지하기 위해 가장 중요한 것은 테이터베이스 쿼리의 최적화와 비지니스 로직의 구현에 사용하는 알고리즘의 최적화이다.
이렇게 최적화 한 다음에는 서버가 요청을 역직렬화하고, 응답에 직렬화하는 부분을 가능한 한 빠르게 만들고, 클리이언트와 서버 간 통신에서의 오버헤드를 줄인다.
요청 마다 새로운 연결을 사용하기보다는 하나의 연결을 오래 사용하는 것도 오버헤드를 줄이는 방법 중 하나이다.

이런 점에서 grpc는 문제 해결에 많은 도움을 준다.

## 서비스를 만들 때의 목표
- 단순화 : gRPC의 추상화는 중 상급 수준이다. gRPC는 어떻게 직렬화할지, 엔드포인트를 어떻게 구성할지 정해져 있으며 높은 추상화이다. (express보다 높음)
gRPC는 미들웨어를 이용해 확장할 수 있다. 로깅, 인증, 속도 제한, 트레이싱과 같은 문제들을 만나는데, 이러한 문제를 해결할 수 있는 많은 미들웨어를 만들어왔다.

- 유지보수: 첫 버전을 만들기까지 걸리는 시간은 서비스에 쏟을 전체 시간의 일부이다. 서비스가 운영을 시작하고 고객이 사용하게 되면 하위 호환성을 신경 써야
요청-응답 형태의 API에서 가장 간단한 해법은 버전으로 구분하여 여러 인스턴스를 두는 것이다.

gRPC에서는 작은 변경일 때는 protobuf의 필드 버저닝으로 충분하며, 메이저 변경이 있을때, 서비스의 여러 버전을 쉽게 작성하고 실행할 수 있다. 모든 요청과 응답의 자료형을 체크하면 실수로라도 하위 호환성을 깨는 일을 막을 수 있다.

- 보안: gRPC는 보안 소켓 계층(Secure Sockets Layer, SSL)과 전송 계층 보안(Transport Layer Security, TLS)를 지원하여 클라이언트와 서버 사이를 오가는 모든 데이터를 암호화한다.

- 사용성: gRPC에서는 서비스 메서드, 요청-응답과 그 본문 모두를 자료형으로 정의한다. 컴파일러는 protobuf에서는 코드로 모든 코멘트를 복사하여 사용자가 자료형 정의만으로 이해하기 어려운 부분을 보완한다.
사용자는 자신이 만든 코드를 자료형 검사해서 API를 제대로 사용하는지 확인할 수 있다. 또한 godoc을 이용하면 gRPC API 상세한 정보를 알 수 있다.

- 성능: gRPC는 protobuf와 HTTP/2를 기반으로 만들어졌다. protobuf는 직렬화에 유리하고 HTTP/2는 연결을 오래 유지할 수 있는 이점이 있다. 덕분에 gRPC를 사용하는 서비스는 효율적으로 구동하며 서버 비용을 아낄 수 있다.

- 확장성: 클라이언트 로드 밸런싱, 프록시 로드 밸런싱, 색인 로드 밸런싱, 서비스 메시 등과 같은 다양한 로드 밸런싱을 쓸 수 있다.

## gRPC 서비스 정의
> gRPC란 관련 있는 RPC 엔드포인트들을 묶은 그룹이다.
> 어떤 관련이 있는지 개발자 판단이다. 어떠한 문제를 해결하는 데 필요한 엔드포인트들이다.

### service 키워드

---
컴파일러가 생성해야할 서비스라는 의미. rpc로 시작하는 각각의 줄은 서비스의 엔드포인트이다.

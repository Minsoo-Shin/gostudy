# 배운점

```
type store struct {
    *os.File
    mu   sync.Mutex
    buf  *bufio.Writer
    size uint64
}
```
### 왜 buf를 객체 안에 두는 것일까? 

### 버퍼링은 작은 단위로 파일에 쓰기할 경우 I/O 작업에 여러 가지 이점을 제공합니다.  

1. 성능 향상: 작은 단위로 파일 쓰기하는 경우, 매번 파일 시스템에 접근하여 I/O 작업을 수행해야 합니다. 
이는 시간이 많이 소요되는 작업입니다. 하지만 버퍼링을 사용하면 작은 단위의 데이터를 메모리에 버퍼로 쌓아두었다가 한 번에 파일에 쓸 수 있습니다. 
이렇게 함으로써 파일 시스템에 접근하는 횟수를 줄이고, 쓰기 작업을 더 효율적으로 수행할 수 있습니다.

2. 시스템 호출 감소: 작은 단위로 파일에 쓰기를 하는 경우, 매번 시스템 호출을 수행하여 파일에 데이터를 쓰는 작업을 해야 합니다. 
시스템 호출은 비교적 많은 오버헤드가 발생하는 작업이기 때문에, 이를 최소화하는 것이 중요합니다. 
버퍼링을 사용하면 작은 데이터 덩어리를 한 번에 파일에 쓰는 것이므로, 시스템 호출 횟수를 줄일 수 있습니다. 이로써 시스템 호출에 따른 오버헤드를 감소시킬 수 있습니다.

3. 원자성과 일관성: 파일에 작은 단위로 쓰기를 여러 번 수행하는 경우, 여러 개의 작은 데이터가 파일에 불연속적으로 저장될 수 있습니다. 
이는 파일의 내용을 일관성 있게 유지하는 데 어려움을 줄 수 있습니다. 버퍼링을 사용하면 작은 단위의 데이터를 모아서 한 번에 쓰는 것이므로, 파일에 저장되는 데이터는 더 연속적이고 일관성 있게 됩니다.

4. 프로그램 성능 향상: 버퍼링은 파일에 쓰기 작업에 대한 프로그램의 성능을 향상시킬 수 있습니다. 
작은 단위로 파일에 쓰는 경우, 각 쓰기 작업마다 대기 시간이 발생하여 프로그램의 실행 속도가 느려질 수 있습니다. 
하지만 버퍼링을 사용하면 작은 단위의 데이터를 한 번에 쓰기 때문에, 대기 시간이 감소하고 프로그램이 빠르게 실행될 수 있습니다.

따라서, 작은 단위로 파일에 쓰기를 하는 경우 버퍼링을 사용하면 I/O 작업의 효율성을 높여 성능을 향상시킬 수 있습니다.

### 그렇다면 단점은 없을까?
1. 메모리 사용: 버퍼링은 작은 단위의 데이터를 메모리에 보관하는 것입니다. 따라서 버퍼의 크기와 버퍼링 되는 데이터 양에 따라 메모리 사용량이 증가할 수 있습니다. 
2. 데이터 무결성 위험: 버퍼링은 데이터를 메모리에 저장했다가 한번에 파일에 쓰는 방식이라 버퍼에 저장된 데이터가 손실되거나 프로그램 실행 중 갑작스러운 오류, 충돌이 가능하다. 
3. 실시간 데이터 지연: 데이터가 파일에 기록되기까지 약간의 지연이 발생합니다. 적절한 버퍼 크기와 쓰기 빈도를 설정해야합니다. 
4. 데이터 일관성 위험: 작은 단위의 데이터를 모아서 주기적으로 한번에 파일에 쓰기 때문에 도중에 프로그램 문제가 발생한다면, 일부 데이터만 남아있는 경우가 있습니다.

### 버퍼의 크기와 주기를 정하는 기준은 무엇일까? 
고려사항: 처리량, 실시간성, 가용메모리, 네트워크 상황
- 처리량이 높은 경우, 큰 버퍼를 사용하여 한번에 많은 양의 데이터를 쓸 수 있습니다. 
- 실시간 응답이 필요하는 경우 작은 주기로 파일을 쓰는게 적합합니다. 
- 메모리 제한을 초과하지 않는 버퍼 크기를 선택해야합니다. 
- 네트워크 대역폭과 지연 시간을 고려하여 작은 주기로 데이터를 쓰는 것이 유리할 수 있습니다. 

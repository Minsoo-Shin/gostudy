# 동시성이 항상 빠른 것은 아닙니다.
고루틴을 만들어서 동시성을 사용하면 더 빠르게 작업을 수행할 수 있지만 항상 빠른 것은 아니라는 사실을 기억해야 합니다.
예를 들어, 각 작업이 단순하다면 고루틴을 생성하고 스케쥴링하는 데 드는 비용이 더 크게 들 수 있습니다. 이를 테스트하기 위해서 코드를 작성했습니다.

# 실험 내용
- 정렬되지 않은 배열을 만들고 이를 MergeSort로 정렬합니다. 이 때, 동시성을 사용하는 방법과 순차 연산하는 방법을 비교합니다.
    - 순차 정렬
    - 고루틴을 사용한 동시 정렬
    - 고루틴을 사용한 동시 정렬 (배열이 작은 경우 순차 정렬)

# 실험 결과
배열을 절반 나누어 정렬하는 작업을 재귀적으로 병렬적으로 하면 배열의 크기가 1이 될 때까지 작업을 나눠 수행합니다. 이 때문에 오히려 비효율적인 고루틴 생성 및 컨텍스트 스위칭, 스케쥴링 비용이 생깁니다. 이 때문에 특정 크기 이하의 배열에 대해서는 순차적으로 정렬하는 것이 더 빠릅니다.

<img width="316" alt="Screenshot 2024-10-22 at 6 08 54 PM" src="https://github.com/user-attachments/assets/debb7b16-b2a6-476e-a83e-88f46b91f411">
